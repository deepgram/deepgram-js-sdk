// This file was auto-generated by Fern from our API Definition.

import * as core from "../../../../../../core/index.js";
import { fromJson, toJson } from "../../../../../../core/json.js";
import type * as Deepgram from "../../../../../index.js";

type MessageEvent = { data: string | ArrayBuffer | Blob | Buffer };

export declare namespace V1Socket {
    export interface Args {
        socket: core.ReconnectingWebSocket;
    }

    export type Response =
        | Deepgram.listen.ListenV1Results
        | Deepgram.listen.ListenV1Metadata
        | Deepgram.listen.ListenV1UtteranceEnd
        | Deepgram.listen.ListenV1SpeechStarted;
    type EventHandlers = {
        open?: () => void;
        message?: (message: Response) => void;
        close?: (event: core.CloseEvent) => void;
        error?: (error: Error) => void;
    };
}

export class V1Socket {
    public readonly socket: core.ReconnectingWebSocket;
    protected readonly eventHandlers: V1Socket.EventHandlers = {};
    private handleOpen: () => void = () => {
        this.eventHandlers.open?.();
    };
    private handleMessage: (event: MessageEvent) => void = (event) => {
        // Handle both text (JSON) and binary messages
        if (typeof event.data === "string") {
            try {
                const data = fromJson(event.data);
                this.eventHandlers.message?.(data as V1Socket.Response);
            } catch (error) {
                // If JSON parsing fails, pass the raw string
                this.eventHandlers.message?.(event.data as unknown as V1Socket.Response);
            }
        } else {
            // Binary data - pass through as-is (though listen API typically sends JSON)
            // This handles cases where binary might be sent
            this.eventHandlers.message?.(event.data as unknown as V1Socket.Response);
        }
    };
    private handleClose: (event: core.CloseEvent) => void = (event) => {
        this.eventHandlers.close?.(event);
    };
    private handleError: (event: core.ErrorEvent) => void = (event) => {
        const message = event.message;
        this.eventHandlers.error?.(new Error(message));
    };

    constructor(args: V1Socket.Args) {
        this.socket = args.socket;
        // Don't register handlers here - they'll be registered in connect()
        // This prevents duplicate handlers when connect() is called
    }

    /** The current state of the connection; this is one of the readyState constants. */
    get readyState(): number {
        return this.socket.readyState;
    }

    /**
     * @param event - The event to attach to.
     * @param callback - The callback to run when the event is triggered.
     * Usage:
     * ```typescript
     * this.on('open', () => {
     *     console.log('The websocket is open');
     * });
     * ```
     */
    public on<T extends keyof V1Socket.EventHandlers>(event: T, callback: V1Socket.EventHandlers[T]): void {
        this.eventHandlers[event] = callback;
    }

    public sendListenV1Media(message: string): void {
        this.assertSocketIsOpen();
        this.sendJson(message);
    }

    public sendListenV1Finalize(message: Deepgram.listen.ListenV1Finalize): void {
        this.assertSocketIsOpen();
        this.sendJson(message);
    }

    public sendListenV1CloseStream(message: Deepgram.listen.ListenV1CloseStream): void {
        this.assertSocketIsOpen();
        this.sendJson(message);
    }

    public sendListenV1KeepAlive(message: Deepgram.listen.ListenV1KeepAlive): void {
        this.assertSocketIsOpen();
        this.sendJson(message);
    }

    /** Connect to the websocket and register event handlers. */
    public connect(): V1Socket {
        // Only reconnect if socket is closed, not if it's already connecting or open
        if (this.socket.readyState === core.ReconnectingWebSocket.CLOSED) {
            this.socket.reconnect();
        }

        this.socket.addEventListener("open", this.handleOpen);
        this.socket.addEventListener("message", this.handleMessage);
        this.socket.addEventListener("close", this.handleClose);
        this.socket.addEventListener("error", this.handleError);

        return this;
    }

    /** Close the websocket and unregister event handlers. */
    public close(): void {
        this.socket.close();

        this.handleClose({ code: 1000 } as CloseEvent);

        this.socket.removeEventListener("open", this.handleOpen);
        this.socket.removeEventListener("message", this.handleMessage);
        this.socket.removeEventListener("close", this.handleClose);
        this.socket.removeEventListener("error", this.handleError);
    }

    /** Returns a promise that resolves when the websocket is open. */
    public async waitForOpen(): Promise<core.ReconnectingWebSocket> {
        if (this.socket.readyState === core.ReconnectingWebSocket.OPEN) {
            return this.socket;
        }

        return new Promise((resolve, reject) => {
            const openHandler = () => {
                this.socket.removeEventListener("open", openHandler);
                this.socket.removeEventListener("error", errorHandler);
                this.socket.removeEventListener("close", closeHandler);
                resolve(this.socket);
            };

            const errorHandler = (event: unknown) => {
                this.socket.removeEventListener("open", openHandler);
                this.socket.removeEventListener("error", errorHandler);
                this.socket.removeEventListener("close", closeHandler);
                reject(event);
            };

            const closeHandler = (event: core.CloseEvent) => {
                // Only reject if closed with code 1000 (normal closure) before opening
                // This indicates a deliberate close, not a retry-able error
                // Other close codes will trigger error events which we handle separately
                if (event.code === 1000 && this.socket.readyState !== core.ReconnectingWebSocket.OPEN) {
                    this.socket.removeEventListener("open", openHandler);
                    this.socket.removeEventListener("error", errorHandler);
                    this.socket.removeEventListener("close", closeHandler);
                    reject(new Error(`Connection closed before opening: ${event.code} ${event.reason || ""}`));
                }
                // For other close codes, let the error handler or retry logic handle it
            };

            this.socket.addEventListener("open", openHandler);
            this.socket.addEventListener("error", errorHandler);
            this.socket.addEventListener("close", closeHandler);
        });
    }

    /** Asserts that the websocket is open. */
    private assertSocketIsOpen(): void {
        if (!this.socket) {
            throw new Error("Socket is not connected.");
        }

        if (this.socket.readyState !== core.ReconnectingWebSocket.OPEN) {
            throw new Error("Socket is not open.");
        }
    }

    /** Send a binary payload to the websocket. */
    protected sendBinary(payload: ArrayBufferLike | Blob | ArrayBufferView): void {
        this.socket.send(payload);
    }

    /** Send a JSON payload to the websocket. */
    protected sendJson(
        payload:
            | string
            | Deepgram.listen.ListenV1Finalize
            | Deepgram.listen.ListenV1CloseStream
            | Deepgram.listen.ListenV1KeepAlive,
    ): void {
        const jsonPayload = toJson(payload);
        this.socket.send(jsonPayload);
    }
}
